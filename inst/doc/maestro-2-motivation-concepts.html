<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Motivation and Concepts</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Motivation and Concepts</h1>



<div id="what-is-maestro" class="section level2">
<h2>What is maestro?</h2>
<p><code>maestro</code> is an R package for creating and orchestrating
many data pipelines in R. If you have several batch jobs/pipelines that
you want to schedule and monitor from within a single R project, then
<code>maestro</code> is for you. All you do is <em>decorate</em> R
functions with special <code>roxygen2</code> tags and then execute an
orchestrator script:</p>
</div>
<div id="why-do-i-need-maestro" class="section level2">
<h2>Why do I need maestro?</h2>
<p>Running data pipelines is an essential component of data engineering.
It is not unusual to have dozens of pipelines that need to run at
different frequencies, and when you go to deploy these pipelines
scheduling and monitoring them quickly becomes unwieldy. Perhaps you’ve
considered moving to heftier orchestration suites such as Airflow,
Dagster, and others which require learning entirely new skills and pose
their own challenges with deployment. <code>maestro</code> allows you to
orchestrate your pipelines entirely in R. All you then need is an
environment to deploy your <code>maestro</code> project.</p>
</div>
<div id="pipelines" class="section level2">
<h2>Pipelines</h2>
<p>A pipeline is some process that takes raw data (often from an
external source) and moves it somewhere else often transforming it along
the way. Think of a pipeline as a factory assembly line where data is
the raw material. As this data travels along the pipeline, it undergoes
various transformations—such as cleaning, aggregation, and
analysis—making it increasingly refined and valuable. The refined
product is then stored in a new location where it can be used either by
an end consumer or another pipeline. The prototypical type of pipeline
in data engineering is ETL (<strong>E</strong>xtract,
<strong>T</strong>ransform, <strong>L</strong>oad), where data is
extracted from a source, transformed, then loaded into storage.</p>
<div id="scheduled-batch-processing" class="section level3">
<h3>Scheduled Batch Processing</h3>
<p>The pipeline needs to run regularly and automatically to process new
data. Most analytic workloads undergo batch processing - the processing
of data in discrete timed batches. In scheduled batch processing, you as
the engineer decide how often you want your pipeline to run (every day
at 12:00?, every hour on the 15th minute?).</p>
<p>In <code>maestro</code> a pipeline is an R function with
<code>roxygen2</code> comments for scheduling and configuration:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co">#&#39; my_pipe maestro pipeline</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="co">#&#39;</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="co">#&#39; @maestroFrequency 1 day</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="co">#&#39; @maestroStartTime 2024-05-24</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>my_pipe <span class="ot">&lt;-</span> <span class="cf">function</span>() {</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>  random_data <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>    <span class="at">letters =</span> <span class="fu">sample</span>(letters, <span class="dv">10</span>),</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a>    <span class="at">numbers =</span> <span class="fu">sample.int</span>(<span class="dv">10</span>)</span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a>  )</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a>  </span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>  <span class="fu">write.csv</span>(random_data, <span class="at">file =</span> <span class="fu">tempfile</span>())</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a>}</span></code></pre></div>
</div>
</div>
<div id="orchestrator" class="section level2">
<h2>Orchestrator</h2>
<p>An orchestrator is a process that triggers pipelines to run. Think of
it as the factory manager who turns on various assembly lines as needed.
It also monitors all the pipelines to ensure smooth operation. Just like
the factory manager, the orchestrator operates in “shifts” and so needs
to be scheduled to perform it’s job too.</p>
<div id="rounded-scheduling" class="section level3">
<h3>Rounded Scheduling</h3>
<p>Importantly, <code>maestro</code> needs to know how often you’re
going to run the orchestrator. Unlike most orchestration tools out
there, <code>maestro</code> isn’t intended to be continuously running,
which saves you on compute resources. But this means that pipelines
won’t necessarily run <em>exactly</em> when they’re scheduled to. This
is a concept we call <em>rounded scheduling.</em></p>
<p>Let’s say we have a pipeline scheduled to run hourly on the 02 minute
mark (e.g., 01:02, 02:02, etc.), and our orchestrator runs every hour on
the 00 minute. When the orchestrator runs, it’ll be slightly before the
pipeline scheduled time, but it’ll trigger the pipeline anyway because
it’s close enough within the frequency of the orchestrator. If instead
our orchestrator ran every 15 minutes, it’d still only execute the
pipeline once in the hour. But if we underprovisioned the orchestrator
and ran it only every day, then the pipeline would only execute once a
day. So an important guideline is that the orchestrator needs to run at
least as frequency as your highest frequency pipeline.</p>
<p>In <code>maestro</code> an orchestrator is an R script or Quarto like
this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">library</span>(maestro)</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>schedule_table <span class="ot">&lt;-</span> <span class="fu">build_schedule</span>()</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a><span class="fu">run_schedule</span>(</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>  schedule_table,</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>  <span class="at">orch_frequency =</span> <span class="st">&quot;1 hour&quot;</span></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>)</span></code></pre></div>
<p>By passing the <code>orch_frequency = &quot;1 hour&quot;</code> to
<code>run_schedule()</code>, we’re saying that we intend to run the
orchestrator every 1 hour.</p>
</div>
</div>
<div id="comparison-with-other-packages" class="section level2">
<h2>Comparison with other packages</h2>
<div id="r-targets" class="section level3">
<h3>{R} targets</h3>
<p><a href="https://docs.ropensci.org/targets/index.html">targets</a> is
a “pipeline tool for statistics and data science in R”. If you have
multiple connected components of a pipeline, <code>targets</code> skips
computation of tasks that are up-to-date. <code>targets</code> seems to
be primarily used for projects with a single output (e.g., model,
document) where there are multiple steps that cumulatively take a long
time to complete. In contrast, <code>maestro</code> is focused on
projects with multiple <em>independent</em> pipelines. Moreover,
<code>maestro</code> pipelines are primarily used when the
<em>up-to-dateness</em> of the source data is unknown (e.g., coming from
an API or database), unlike in <code>targets</code> where it determines
the <em>up-to-dateness</em> based on the contents of a file.</p>
<p>That said, <code>targets</code> and <code>maestro</code> may be
complimentary in a single project. One possible case would be to use
<code>maestro</code> to orchestrate <code>targets</code> pipelines for
tasks such as ETL (e.g., <code>maestro</code> kicks off the pipeline but
then downstream computations are avoided if there’s no new data from
source). This is a possible exciting integration that we hope to
investigate further!</p>
</div>
<div id="python-dagster" class="section level3">
<h3>{Python} dagster</h3>
<p><a href="https://dagster.io/">Dagster</a> is an “open source
orchestration platform for the development, production, and observation
of data assets”. Like <code>maestro</code>, dagster uses decorators
(special comments) to configure <em>data assets</em> (functions). Unlike
<code>maestro</code>, dagster is primarily for chaining together
dependent components of a multi-step pipeline - a DAG. It also supports
a developer UI and is more fully developed than <code>maestro</code> at
the current time.</p>
<p>DAG support is something we’ve considered for <code>maestro</code>.
It seems feasible but would be a dramatic step up in the complexity of
the package. Conceivably, you could tag <code>maestro</code> pipelines
to form a dependency graph and then <code>maestro</code> would validate
the graph and coordinate the chaining and passing of data from one
component to the next.</p>
</div>
</div>
<div id="when-to-not-use-maestro" class="section level2">
<h2>When to not use maestro?</h2>
<p>While <code>maestro</code> can be used for almost any data
engineering task that can be performed in R, there are cases where it is
less appropriate to use it.</p>
<div id="streaming-and-event-driven" class="section level3">
<h3>Streaming and Event-driven</h3>
<p><code>maestro</code> does not support streaming (i.e., continuous) or
event-driven pipelines. Only batch processes can be run in
<code>maestro</code>.</p>
</div>
<div id="hundreds-of-pipelines" class="section level3">
<h3>Hundreds of pipelines</h3>
<p>Although there is no hard limit to the number of pipelines you can
run in <code>maestro</code> (and there are ways of maximizing its
efficiency as the number of pipelines increases, such as using multiple
cores), we advise against using <code>maestro</code> to run
<em>this</em> many pipelines - at least not in a single project. There
are several reasons for this: (1) the orchestrator execution time will
be become a problem even with multiple cores; (2) organizing and keeping
track of this many pipelines in a single R project becomes difficult;
(3) the number of dependencies to manage in the project will likely
balloon.</p>
<p>If you wish to continue using <code>maestro</code> in this scenario,
then our recommendation is to split the jobs into multiple projects all
running on <code>maestro</code>.</p>
<p>Nevertheless, if you have hundreds of jobs to run it’s likely an
indicator that your enterprise has matured out of <code>maestro</code>
into something a bit more sophisticated.</p>
</div>
<div id="high-frequency-jobs" class="section level3">
<h3>High frequency jobs</h3>
<p>If you have pipelines that need to run every minute or less you may
want to look for a solution that supports near real time or real time
data processing. The orchestrator may have trouble keeping up if it’s
scheduled to run this often.</p>
</div>
<div id="multiple-languages-r-python" class="section level3">
<h3>Multiple languages (R + Python)</h3>
<p><code>maestro</code> is for R pipelines only. Using
<code>reticulate</code> may help with Python in a pinch though.</p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
